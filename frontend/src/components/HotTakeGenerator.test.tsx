import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import HotTakeGenerator from './HotTakeGenerator';

// Mock fetch globally
globalThis.fetch = vi.fn();

// Mock config module
vi.mock('../config', () => ({
  default: {
    apiBaseUrl: 'http://localhost:8000',
  },
}));

// ---------------------------------------------------------------------------
// SSE stream helpers
// ---------------------------------------------------------------------------

const encoder = new TextEncoder();

/** Build a mock fetch response that streams SSE events. */
function makeSseResponse(events: object[]) {
  const lines = events.map(e => `data: ${JSON.stringify(e)}\n\n`).join('');
  const chunk = encoder.encode(lines);
  return {
    ok: true,
    body: {
      getReader: () => ({
        read: vi
          .fn()
          .mockResolvedValueOnce({ done: false, value: chunk })
          .mockResolvedValueOnce({ done: true, value: undefined }),
      }),
    },
  };
}

function makeDoneResponse(overrides: Partial<{
  hot_take: string;
  topic: string;
  style: string;
  agent_used: string;
  web_search_used: boolean;
  news_context: string;
  sources: object[];
}> = {}) {
  return makeSseResponse([
    { type: 'status', message: 'Generating...' },
    { type: 'token', text: overrides.hot_take ?? 'Test hot take' },
    {
      type: 'done',
      hot_take: overrides.hot_take ?? 'Test hot take',
      topic: overrides.topic ?? 'Test',
      style: overrides.style ?? 'controversial',
      agent_used: overrides.agent_used ?? 'test-agent',
      web_search_used: overrides.web_search_used ?? false,
      news_context: overrides.news_context ?? null,
      sources: overrides.sources ?? null,
    },
  ]);
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

describe('HotTakeGenerator', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  it('renders the form with all required fields', () => {
    render(<HotTakeGenerator />);

    expect(screen.getByLabelText(/topic/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/style/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/include web search results/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/include recent news articles/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /generate hot take/i })).toBeInTheDocument();
    expect(screen.getByText(/for fun only\. ai-generated opinions may be wrong\./i)).toBeInTheDocument();
  });

  it('has submit button disabled when topic is empty', () => {
    render(<HotTakeGenerator />);

    const submitButton = screen.getByRole('button', { name: /generate hot take/i });
    expect(submitButton).toBeDisabled();
  });

  it('enables submit button when topic is entered', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'AI in education');

    expect(submitButton).not.toBeDisabled();
  });

  it('shows loading state when generating hot take', async () => {
    const user = userEvent.setup();

    // Never resolves â€” simulates in-flight stream
    (globalThis.fetch as ReturnType<typeof vi.fn>).mockImplementationOnce(
      () => new Promise(() => {})
    );

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'AI in education');
    await user.click(submitButton);

    expect(screen.getByText(/generating\.\.\./i)).toBeInTheDocument();
    expect(submitButton).toBeDisabled();
  });

  it('displays hot take after successful generation', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({
        hot_take: 'AI will replace all teachers by 2030!',
        topic: 'AI in education',
        agent_used: 'test-agent',
      })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'AI in education');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(
        screen.getByText('AI will replace all teachers by 2030!')
      ).toBeInTheDocument();
    });

    expect(screen.getByRole('heading', { name: /your hot take/i })).toBeInTheDocument();
    expect(screen.getByText(/generated by:/i)).toBeInTheDocument();
    expect(screen.getByText('test-agent')).toBeInTheDocument();
  });

  it('renders markdown formatting in the final hot take output', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({
        hot_take: '# Bold Claim\n- Point one\n- Point two\n**Strong take**',
        topic: 'Formatting',
      })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Formatting');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByRole('heading', { name: 'Bold Claim' })).toBeInTheDocument();
      expect(screen.getByRole('list')).toBeInTheDocument();
      expect(screen.getByText('Strong take')).toBeInTheDocument();
    });
  });

  it('shows the disclaimer after generation completes', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({
        hot_take: 'Final generated take',
        topic: 'Disclaimer check',
      })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Disclaimer check');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(
        screen.getByText(/ai-generated opinion for entertainment purposes only\./i)
      ).toBeInTheDocument();
    });
  });

  it('does not show the disclaimer while streaming', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeSseResponse([
        { type: 'status', message: 'Generating...' },
        { type: 'token', text: 'Streaming output' },
      ])
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Streaming check');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByText(/streaming output/i)).toBeInTheDocument();
    });
    expect(
      screen.queryByText(/ai-generated opinion for entertainment purposes only\./i)
    ).not.toBeInTheDocument();
  });

  it('displays error message on failed generation', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: false,
      json: async () => ({}),
    });

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'AI in education');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByText(/failed to generate hot take/i)).toBeInTheDocument();
    });
  });

  it('displays backend error detail when provided', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: false,
      json: async () => ({ detail: 'Failed to generate hot take. Please try again.' }),
    });

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'AI in education');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(
        screen.getByText(/failed to generate hot take\. please try again\./i)
      ).toBeInTheDocument();
    });
  });

  it('does not show success toast when generation fails', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: false,
      json: async () => ({ detail: 'Rate limit exceeded.' }),
    });

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'AI in education');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByText(/rate limit exceeded\./i)).toBeInTheDocument();
    });
    expect(screen.queryByText(/hot take generated!/i)).not.toBeInTheDocument();
  });

  it('shows source count selector when any search mode is enabled', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const webSearchCheckbox = screen.getByLabelText(/include web search results/i);
    const newsSearchCheckbox = screen.getByLabelText(/include recent news articles/i);

    expect(screen.queryByLabelText(/number of sources to include/i)).not.toBeInTheDocument();

    await user.click(webSearchCheckbox);
    expect(screen.getByLabelText(/number of sources to include/i)).toBeInTheDocument();

    await user.click(newsSearchCheckbox);
    expect(screen.getByLabelText(/number of sources to include/i)).toBeInTheDocument();

    await user.click(webSearchCheckbox);
    expect(screen.getByLabelText(/number of sources to include/i)).toBeInTheDocument();

    await user.click(newsSearchCheckbox);
    expect(screen.queryByLabelText(/number of sources to include/i)).not.toBeInTheDocument();
  });

  it('changes style when dropdown is selected', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const styleSelect = screen.getByLabelText(/style/i) as HTMLSelectElement;
    expect(styleSelect.value).toBe('controversial');

    await user.selectOptions(styleSelect, 'sarcastic');
    expect(styleSelect.value).toBe('sarcastic');
  });

  it('sends correct data to streaming API', async () => {
    const user = userEvent.setup();
    const mockFetch = vi.fn().mockResolvedValueOnce(
      makeDoneResponse({ hot_take: 'Test take', topic: 'Testing', style: 'sarcastic' })
    );
    globalThis.fetch = mockFetch;

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Testing');
    await user.selectOptions(screen.getByLabelText(/style/i), 'sarcastic');
    await user.click(screen.getByLabelText(/include web search results/i));
    await user.click(screen.getByLabelText(/include recent news articles/i));
    await user.selectOptions(screen.getByLabelText(/number of sources to include/i), '5');
    await user.selectOptions(screen.getByLabelText(/web search provider/i), 'brave');
    await user.selectOptions(screen.getByLabelText(/news recency window/i), '7');
    await user.click(screen.getByLabelText(/strict source quality mode/i));
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        'http://localhost:8000/api/generate/stream',
        expect.objectContaining({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            topic: 'Testing',
            style: 'sarcastic',
            use_web_search: true,
            use_news_search: true,
            max_articles: 5,
            web_search_provider: 'brave',
            news_days: 7,
            strict_quality_mode: true,
          }),
        })
      );
    });
  });

  it('includes default agent_type from localStorage in generate request', async () => {
    const user = userEvent.setup();
    localStorage.setItem('defaultAgent', 'openai');

    const mockFetch = vi.fn().mockResolvedValueOnce(
      makeDoneResponse({ agent_used: 'OpenAI Agent' })
    );
    globalThis.fetch = mockFetch;

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Testing');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        'http://localhost:8000/api/generate/stream',
        expect.objectContaining({
          body: expect.stringContaining('"agent_type":"openai"'),
        })
      );
    });
  });

  it('saves structured sources to localStorage when returned by stream', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({
        hot_take: 'Sourced take',
        topic: 'AI',
        style: 'analytical',
        agent_used: 'OpenAI Agent',
        sources: [
          {
            type: 'web',
            title: 'AI News',
            url: 'https://example.com/ai-news',
            snippet: 'Latest AI updates',
            source: 'example.com',
          },
        ],
      })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'AI');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      const saved = localStorage.getItem('recentSources');
      expect(saved).toBeTruthy();
      const parsed = JSON.parse(saved || '[]');
      expect(parsed[0].title).toBe('AI News');
      expect(parsed[0].type).toBe('web');
      expect(parsed[0].url).toBe('https://example.com/ai-news');
    });
  });

  it('displays news context when available', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({
        hot_take: 'News-based hot take!',
        topic: 'Current events',
        style: 'analytical',
        agent_used: 'news-agent',
        web_search_used: true,
        news_context: 'Recent news about current events...',
      })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Current events');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByText(/news sources used/i)).toBeInTheDocument();
      expect(screen.getByText(/news-enhanced:/i)).toBeInTheDocument();
    });
  });

  it('displays sources list when sources event arrives', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeSseResponse([
        { type: 'status', message: 'Searching the web...' },
        {
          type: 'sources',
          sources: [
            { type: 'web', title: 'Example Article', url: 'https://example.com', source: 'example.com' },
          ],
        },
        { type: 'token', text: 'Hot take' },
        {
          type: 'done',
          hot_take: 'Hot take',
          topic: 'test',
          style: 'controversial',
          agent_used: 'Test Agent',
          web_search_used: true,
          sources: [
            { type: 'web', title: 'Example Article', url: 'https://example.com', source: 'example.com' },
          ],
        },
      ])
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'test');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByText('Example Article')).toBeInTheDocument();
    });
  });

  it('displays empty state when no hot take has been generated', () => {
    render(<HotTakeGenerator />);

    expect(screen.getByText(/ready to generate some hot takes/i)).toBeInTheDocument();
    expect(screen.getByText(/enter a topic above/i)).toBeInTheDocument();
  });

  it('shows loading skeleton while generating', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockImplementationOnce(
      () => new Promise(() => {})
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Test topic');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    expect(screen.getByRole('status', { busy: true })).toBeInTheDocument();
  });

  it('toggles dark mode when button is clicked', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const darkModeButton = screen.getByRole('button', { name: /toggle dark mode/i });

    await user.click(darkModeButton);
    expect(document.documentElement.classList.contains('dark-mode')).toBe(true);

    await user.click(darkModeButton);
    expect(document.documentElement.classList.contains('dark-mode')).toBe(false);
  });

  it('shows action buttons after streaming completes', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({ hot_take: 'Test hot take', topic: 'Test' })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Test');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /copy to clipboard/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /share on x\/twitter/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /save hot take/i })).toBeInTheDocument();
    });
  });

  it('saves hot take to localStorage when save button is clicked', async () => {
    const user = userEvent.setup();

    (globalThis.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
      makeDoneResponse({ hot_take: 'Saveable hot take', topic: 'Test' })
    );

    render(<HotTakeGenerator />);

    await user.type(screen.getByLabelText(/topic/i), 'Test');
    await user.click(screen.getByRole('button', { name: /generate hot take/i }));

    await waitFor(() => {
      expect(screen.getByText('Saveable hot take')).toBeInTheDocument();
    });

    await user.click(screen.getByRole('button', { name: /save hot take/i }));

    const saved = localStorage.getItem('savedHotTakes');
    expect(saved).toBeTruthy();
    const parsed = JSON.parse(saved || '[]');
    expect(parsed).toHaveLength(1);
    expect(parsed[0].hot_take).toBe('Saveable hot take');
  });
});
