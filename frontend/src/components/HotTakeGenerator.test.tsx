import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import HotTakeGenerator from './HotTakeGenerator';

// Mock fetch globally
global.fetch = vi.fn();

describe('HotTakeGenerator', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders the form with all required fields', () => {
    render(<HotTakeGenerator />);

    expect(screen.getByLabelText(/topic/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/style/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/include web search results/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/include recent news articles/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /generate hot take/i })).toBeInTheDocument();
  });

  it('has submit button disabled when topic is empty', () => {
    render(<HotTakeGenerator />);

    const submitButton = screen.getByRole('button', { name: /generate hot take/i });
    expect(submitButton).toBeDisabled();
  });

  it('enables submit button when topic is entered', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'AI in education');

    expect(submitButton).not.toBeDisabled();
  });

  it('shows loading state when generating hot take', async () => {
    const user = userEvent.setup();

    // Mock a delayed response
    (global.fetch as ReturnType<typeof vi.fn>).mockImplementationOnce(
      () => new Promise(() => {}) // Never resolves
    );

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'AI in education');
    await user.click(submitButton);

    expect(screen.getByText(/generating\.\.\./i)).toBeInTheDocument();
    expect(submitButton).toBeDisabled();
  });

  it('displays hot take after successful generation', async () => {
    const user = userEvent.setup();
    const mockResponse = {
      hot_take: 'AI will replace all teachers by 2030!',
      topic: 'AI in education',
      style: 'controversial',
      agent_used: 'test-agent',
    };

    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'AI in education');
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText('AI will replace all teachers by 2030!')).toBeInTheDocument();
    });

    // Verify result section is displayed with metadata
    expect(screen.getByRole('heading', { name: /your hot take/i })).toBeInTheDocument();
    expect(screen.getByText(/generated by:/i)).toBeInTheDocument();
    expect(screen.getByText('test-agent')).toBeInTheDocument();
  });

  it('displays error message on failed generation', async () => {
    const user = userEvent.setup();

    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: false,
    });

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'AI in education');
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText(/error:/i)).toBeInTheDocument();
    });
  });

  it('shows results count selector when web search or news search is enabled', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const webSearchCheckbox = screen.getByLabelText(/include web search results/i);
    const newsSearchCheckbox = screen.getByLabelText(/include recent news articles/i);

    // Initially hidden
    expect(screen.queryByLabelText(/number of results to include/i)).not.toBeInTheDocument();

    // Show after web search checkbox is checked
    await user.click(webSearchCheckbox);
    expect(screen.getByLabelText(/number of results to include/i)).toBeInTheDocument();

    // Should still show when web search is unchecked but news search is checked
    await user.click(webSearchCheckbox);
    await user.click(newsSearchCheckbox);
    expect(screen.getByLabelText(/number of results to include/i)).toBeInTheDocument();
  });

  it('changes style when dropdown is selected', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const styleSelect = screen.getByLabelText(/style/i) as HTMLSelectElement;

    expect(styleSelect.value).toBe('controversial');

    await user.selectOptions(styleSelect, 'sarcastic');

    expect(styleSelect.value).toBe('sarcastic');
  });

  it('sends correct data to API including web search and news search options', async () => {
    const user = userEvent.setup();
    const mockFetch = vi.fn().mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        hot_take: 'Test take',
        topic: 'Test topic',
        style: 'sarcastic',
        agent_used: 'test-agent',
      }),
    });

    global.fetch = mockFetch;

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const styleSelect = screen.getByLabelText(/style/i);
    const webSearchCheckbox = screen.getByLabelText(/include web search results/i);
    const newsSearchCheckbox = screen.getByLabelText(/include recent news articles/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'Testing');
    await user.selectOptions(styleSelect, 'sarcastic');
    await user.click(webSearchCheckbox);
    await user.click(newsSearchCheckbox);

    const maxResultsSelect = screen.getByLabelText(/number of results to include/i);
    await user.selectOptions(maxResultsSelect, '5');

    await user.click(submitButton);

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        'http://localhost:8000/api/generate',
        expect.objectContaining({
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            topic: 'Testing',
            style: 'sarcastic',
            use_web_search: true,
            use_news_search: true,
            max_articles: 5,
          }),
        })
      );
    });
  });

  it('displays news context when available', async () => {
    const user = userEvent.setup();
    const mockResponse = {
      hot_take: 'News-based hot take!',
      topic: 'Current events',
      style: 'analytical',
      agent_used: 'news-agent',
      web_search_used: true,
      news_context: 'Recent news about current events...',
    };

    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'Current events');
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText(/news sources used/i)).toBeInTheDocument();
      expect(screen.getByText(/news-enhanced:/i)).toBeInTheDocument();
    });
  });

  it('displays empty state when no hot take has been generated', () => {
    render(<HotTakeGenerator />);

    expect(screen.getByText(/ready to generate some hot takes/i)).toBeInTheDocument();
    expect(screen.getByText(/enter a topic above/i)).toBeInTheDocument();
  });

  it('shows loading skeleton while generating', async () => {
    const user = userEvent.setup();

    // Mock a delayed response
    (global.fetch as ReturnType<typeof vi.fn>).mockImplementationOnce(
      () => new Promise(() => {}) // Never resolves
    );

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'Test topic');
    await user.click(submitButton);

    // Check for skeleton elements
    expect(screen.getByRole('status', { busy: true })).toBeInTheDocument();
  });

  it('toggles dark mode when button is clicked', async () => {
    const user = userEvent.setup();
    render(<HotTakeGenerator />);

    const darkModeButton = screen.getByRole('button', { name: /toggle dark mode/i });

    await user.click(darkModeButton);

    // Check if dark mode class was added to document
    expect(document.documentElement.classList.contains('dark-mode')).toBe(true);

    await user.click(darkModeButton);

    expect(document.documentElement.classList.contains('dark-mode')).toBe(false);
  });

  it('shows action buttons after generating hot take', async () => {
    const user = userEvent.setup();
    const mockResponse = {
      hot_take: 'Test hot take',
      topic: 'Test',
      style: 'controversial',
      agent_used: 'test-agent',
    };

    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'Test');
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /copy to clipboard/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /share on x\/twitter/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /save hot take/i })).toBeInTheDocument();
    });
  });

  it('copies hot take to clipboard when copy button is clicked', async () => {
    const user = userEvent.setup();
    const mockResponse = {
      hot_take: 'Copyable hot take',
      topic: 'Test',
      style: 'controversial',
      agent_used: 'test-agent',
    };

    // Mock clipboard API
    Object.assign(navigator, {
      clipboard: {
        writeText: vi.fn().mockResolvedValue(undefined),
      },
    });

    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'Test');
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText('Copyable hot take')).toBeInTheDocument();
    });

    const copyButton = screen.getByRole('button', { name: /copy to clipboard/i });
    await user.click(copyButton);

    expect(navigator.clipboard.writeText).toHaveBeenCalledWith('Copyable hot take');
  });

  it('saves hot take to localStorage when save button is clicked', async () => {
    const user = userEvent.setup();
    const mockResponse = {
      hot_take: 'Saveable hot take',
      topic: 'Test',
      style: 'controversial',
      agent_used: 'test-agent',
    };

    // Mock localStorage
    const localStorageMock = (() => {
      let store: Record<string, string> = {};
      return {
        getItem: (key: string) => store[key] || null,
        setItem: (key: string, value: string) => { store[key] = value; },
        clear: () => { store = {}; },
      };
    })();
    Object.defineProperty(window, 'localStorage', { value: localStorageMock });

    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });

    render(<HotTakeGenerator />);

    const topicInput = screen.getByLabelText(/topic/i);
    const submitButton = screen.getByRole('button', { name: /generate hot take/i });

    await user.type(topicInput, 'Test');
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText('Saveable hot take')).toBeInTheDocument();
    });

    const saveButton = screen.getByRole('button', { name: /save hot take/i });
    await user.click(saveButton);

    const saved = localStorage.getItem('savedHotTakes');
    expect(saved).toBeTruthy();
    if (saved) {
      const parsed = JSON.parse(saved);
      expect(parsed).toHaveLength(1);
      expect(parsed[0].hot_take).toBe('Saveable hot take');
    }
  });
});
